# /kaggle/working/search_core/openai_handler.py

import openai
import json
import re
import base64
from typing import Dict, Any, List, Optional

from utils import api_retrier

class OpenAIHandler:
    """
    M·ªôt class "adapter" ƒë·ªÉ ƒë√≥ng g√≥i t·∫•t c·∫£ c√°c l·ªánh g·ªçi API ƒë·∫øn OpenAI.
    Che gi·∫•u s·ª± ph·ª©c t·∫°p c·ªßa vi·ªác g·ªçi API v√† cung c·∫•p c√°c ph∆∞∆°ng th·ª©c
    r√µ r√†ng cho c√°c t√°c v·ª• c·ª• th·ªÉ (ph√¢n t√≠ch, VQA, etc.).
    """
    def __init__(self, api_key: str, model: str = "gpt-4o-mini"):
        """
        Kh·ªüi t·∫°o OpenAI Handler.

        Args:
            api_key (str): OpenAI API key.
            model (str): T√™n model m·∫∑c ƒë·ªãnh cho c√°c t√°c v·ª• text.
                         GPT-4o-mini l√† m·ªôt l·ª±a ch·ªçn t·ªët v·ªÅ t·ªëc ƒë·ªô v√† chi ph√≠.
        """
        print(f"--- ü§ñ Kh·ªüi t·∫°o OpenAI Handler v·ªõi model m·∫∑c ƒë·ªãnh: {model} ---")
        self.client = openai.OpenAI(api_key=api_key)
        self.model = model
        # GPT-4o l√† model vision m·∫°nh m·∫Ω nh·∫•t hi·ªán t·∫°i c·ªßa OpenAI
        self.vision_model = "gpt-4o"

    @api_retrier(max_retries=3, initial_delay=2)
    def _openai_chat_completion(self, messages: List[Dict], is_json: bool = True, is_vision: bool = False) -> Optional[str]: # Th√™m Optional[str]
        """
        H√†m con chung ƒë·ªÉ th·ª±c hi·ªán c√°c l·ªánh g·ªçi API chat completion.
        *** PHI√äN B·∫¢N AN TO√ÄN H∆†N ***
        """
        model_to_use = self.vision_model if is_vision else self.model
        response_format = {"type": "json_object"} if is_json else {"type": "text"}
        
        response = self.client.chat.completions.create(
            model=model_to_use,
            messages=messages,
            response_format=response_format,
            temperature=0.1,
            max_tokens=1024
        )
        
        # --- TH√äM KI·ªÇM TRA T·∫†I ƒê√ÇY ---
        if response.choices and response.choices[0].message:
            content = response.choices[0].message.content
            # Tr·∫£ v·ªÅ chu·ªói r·ªóng n·∫øu content l√† None, thay v√¨ tr·∫£ v·ªÅ ch√≠nh None
            return content if content is not None else "" 
        
        # N·∫øu kh√¥ng c√≥ choices ho·∫∑c message, tr·∫£ v·ªÅ chu·ªói r·ªóng
        return ""

    def _encode_image_to_base64(self, image_path: str) -> str:
        """M√£ h√≥a m·ªôt file ·∫£nh th√†nh chu·ªói base64."""
        try:
            with open(image_path, "rb") as image_file:
                return base64.b64encode(image_file.read()).decode('utf-8')
        except Exception as e:
            print(f"--- ‚ö†Ô∏è L·ªói khi m√£ h√≥a ·∫£nh {image_path}: {e} ---")
            return ""

    def enhance_query(self, query: str) -> Dict[str, Any]:
        """
        Ph√¢n t√≠ch truy v·∫•n (KIS, QNA, TRAKE, ho·∫∑c TRACK_VQA) v√† tr√≠ch xu·∫•t c√°c th√†nh ph·∫ßn
        c√≥ c·∫•u tr√∫c ƒë·ªÉ h·ªá th·ªëng c√≥ th·ªÉ h√†nh ƒë·ªông.
        *** PHI√äN B·∫¢N N√ÇNG C·∫§P V·ªöI TRACK_VQA ***
        """
        # Fallback gi·ªù ƒë√¢y linh ho·∫°t h∆°n, ph√π h·ª£p v·ªõi c√°c lo·∫°i task kh√°c nhau
        fallback_result = {
            'search_context': query,
            'specific_question': "" if "?" not in query else query,
            'aggregation_instruction': "",
            'objects_vi': query.split(),
            'objects_en': query.split()
        }
        
        if not self.model: # S·ª≠a l·∫°i ƒë·ªÉ ki·ªÉm tra self.model thay v√¨ self.gemini_model
            print("--- ‚ö†Ô∏è OpenAI model ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o. S·ª≠ d·ª•ng fallback cho enhance_query. ---")
            return fallback_result

        # Prompt m·ªõi, ƒë∆∞·ª£c thi·∫øt k·∫ø l·∫°i ho√†n to√†n v·ªõi c·∫•u tr√∫c JSON m·ªõi v√† 4 lo·∫°i nhi·ªám v·ª•
        prompt = f"""
        You are an expert query analyzer for a sophisticated Vietnamese video search system. Your task is to analyze a user query and break it down into a structured JSON object.

        **JSON Structure to return:**
        - "search_context": (String) The main scene, event, or object to search for. This should be a descriptive phrase.
        - "specific_question": (String) The specific question to ask about an instance. For KIS and TRAKE, this MUST be an empty string "".
        - "aggregation_instruction": (String) A command in English describing how to combine multiple answers. This is ONLY for TRACK_VQA tasks. For all other tasks, it MUST be an empty string "".
        - "objects_vi": (Array of Strings) A list of important Vietnamese nouns/entities from the "search_context".
        - "objects_en": (Array of Strings) The direct English translation for EACH item in "objects_vi". The two lists must have the same length.

        **Detailed Examples:**

        1.  **TRACK_VQA Query:** "trong bu·ªïi tr√¨nh di·ªÖn m√∫a l√¢n, ƒë·∫øm xem c√≥ bao nhi√™u con l√¢n v√† c√≥ m√†u g√¨"
            **JSON:** {{
                "search_context": "bu·ªïi tr√¨nh di·ªÖn m√∫a l√¢n c√≥ c√°c con l√¢n",
                "specific_question": "Con l√¢n trong ·∫£nh n√†y c√≥ m√†u g√¨?",
                "aggregation_instruction": "Count the unique lions and list their colors from the answers.",
                "objects_vi": ["m√∫a l√¢n", "con l√¢n"],
                "objects_en": ["lion dance", "lion"]
            }}

        2.  **QNA Query:** "Ng∆∞·ªùi ph·ª• n·ªØ m·∫∑c v√°y ƒë·ªè trong b·ªØa ti·ªác ƒëang c·∫ßm ly m√†u g√¨?"
            **JSON:** {{
                "search_context": "b·ªØa ti·ªác c√≥ ng∆∞·ªùi ph·ª• n·ªØ m·∫∑c v√°y ƒë·ªè",
                "specific_question": "c√¥ ·∫•y ƒëang c·∫ßm ly m√†u g√¨?",
                "aggregation_instruction": "",
                "objects_vi": ["b·ªØa ti·ªác", "ng∆∞·ªùi ph·ª• n·ªØ", "v√°y ƒë·ªè"],
                "objects_en": ["party", "woman", "red dress"]
            }}

        3.  **TRAKE Query:** "t√¨m c·∫£nh m·ªôt ng∆∞·ªùi (1) ch·∫°y ƒë·∫øn, (2) nh·∫£y l√™n, (3) ti·∫øp ƒë·∫•t"
            **JSON:** {{
                "search_context": "m·ªôt ng∆∞·ªùi ƒëang th·ª±c hi·ªán c√∫ nh·∫£y",
                "specific_question": "",
                "aggregation_instruction": "",
                "objects_vi": ["ng∆∞·ªùi", "c√∫ nh·∫£y"],
                "objects_en": ["person", "jump"]
            }}

        4.  **KIS Query:** "c·∫£nh m·ªôt chi·∫øc xe bu√Ωt m√†u v√†ng tr√™n ƒë∆∞·ªùng ph·ªë"
            **JSON:** {{
                "search_context": "c·∫£nh m·ªôt chi·∫øc xe bu√Ωt m√†u v√†ng tr√™n ƒë∆∞·ªùng ph·ªë",
                "specific_question": "",
                "aggregation_instruction": "",
                "objects_vi": ["xe bu√Ωt m√†u v√†ng", "ƒë∆∞·ªùng ph·ªë"],
                "objects_en": ["yellow bus", "street"]
            }}

        **Your Task:**
        Analyze the following query and return ONLY the valid JSON object.

        **Query:** "{query}"
        **JSON:**
        """
        try:
            response_content = self._openai_chat_completion([{"role": "user", "content": prompt}], is_json=True)
            result = json.loads(response_content)
            
            # Validate c√°c tr∆∞·ªùng quan tr·ªçng
            if all(k in result for k in ['search_context', 'specific_question', 'aggregation_instruction', 'objects_vi', 'objects_en']):
                print(f"--- ‚úÖ Ph√¢n t√≠ch truy v·∫•n chi ti·∫øt th√†nh c√¥ng. Context: '{result['search_context']}' ---")
                return result
            
            print("--- ‚ö†Ô∏è JSON chi ti·∫øt t·ª´ OpenAI kh√¥ng h·ª£p l·ªá. S·ª≠ d·ª•ng fallback. ---")
            return fallback_result
        except Exception as e:
            print(f"L·ªói OpenAI enhance_query: {e}")
            return fallback_result

    def analyze_task_type(self, query: str) -> str:
        """
        Ph√¢n lo·∫°i truy v·∫•n th√†nh 'KIS', 'QNA', 'TRAKE', ho·∫∑c 'TRACK_VQA' v·ªõi s·ª± t·∫≠p trung
        v√†o vi·ªác ph√¢n bi·ªát gi·ªØa c√¢u h·ªèi v·ªÅ m·ªôt ƒë·ªëi t∆∞·ª£ng (QNA) v√† m·ªôt t·∫≠p h·ª£p (TRACK_VQA).
        """
        prompt = f"""
        You are an expert query classifier for a video search system. Your task is to analyze a Vietnamese query and classify it into one of four precise categories: "KIS", "QNA", "TRAKE", or "TRACK_VQA".

        **Core Principle: Singular vs. Plural/Collection**

        1.  **QNA (Question Answering - Singular):** The query asks a question about a SINGLE, implicitly defined subject. The user assumes we can find that one subject and wants a specific detail about IT.
            - **Keywords:** Often uses singular nouns (e.g., "ng∆∞·ªùi ƒë√†n √¥ng", "chi·∫øc xe").
            - **Test:** Can the question be answered by looking at only ONE frame? If yes, it's likely QNA.
            - **Example:** "ng∆∞·ªùi ƒë√†n √¥ng ƒëang c·∫ßm v·∫≠t g√¨ tr√™n tay?" (Asks about ONE specific man)
            - **Example:** "What color is THE car?"

        2.  **TRACK_VQA (Tracking & VQA - Plural/Collection):** The query asks a question that requires finding a COLLECTION of objects/events first, and then AGGREGATING information about them.
            - **Keywords:** Often uses plural nouns ("nh·ªØng chi·∫øc xe", "c√°c con l√¢n") or aggregation words ("ƒë·∫øm", "bao nhi√™u", "li·ªát k√™", "t·∫•t c·∫£", "m·ªói").
            - **Test:** Does the user need to see MULTIPLE moments to get the final answer? If yes, it's TRACK_VQA.
            - **Example:** "ƒë·∫øm xem c√≥ bao nhi√™u chi·∫øc xe m√†u ƒë·ªè" (Must find ALL red cars, then count)
            - **Example:** "li·ªát k√™ m√†u c·ªßa t·∫•t c·∫£ c√°c con l√¢n" (Must find ALL lions, then list their colors)

        3.  **TRAKE (Temporal Alignment):** Asks for a SEQUENCE of DIFFERENT actions in a specific order.
            - **Example:** "t√¨m c·∫£nh ng∆∞·ªùi (1) ƒë·ª©ng l√™n v√† (2) r·ªùi ƒëi"

        4.  **KIS (Knowledge Intensive Search):** A simple description of a scene. Not a question, not a sequence, not a request for aggregation.
            - **Example:** "c·∫£nh m√∫a l√¢n"

        **Your Task:**
        Analyze the following query and return ONLY the category as a single word.

        **Query:** "{query}"
        **Category:**
        """
        try:
            response = self._openai_chat_completion([{"role": "user", "content": prompt}], is_json=False)
            task_type = response.strip().upper()
            
            if task_type in ["KIS", "QNA", "TRAKE", "TRACK_VQA"]:
                print(f"--- ‚úÖ Ph√¢n lo·∫°i truy v·∫•n (OpenAI): '{query}' -> {task_type} ---")
                return task_type
                
            print(f"--- ‚ö†Ô∏è Ph√¢n lo·∫°i kh√¥ng h·ª£p l·ªá t·ª´ OpenAI: '{task_type}'. Fallback v·ªÅ Heuristic. ---")
            return self._analyze_query_heuristic_fallback(query)

        except Exception as e:
            print(f"L·ªói OpenAI analyze_task_type: {e}. Fallback v·ªÅ Heuristic.")
            return self._analyze_query_heuristic_fallback(query)

    def _analyze_query_heuristic_fallback(self, query: str) -> str:
        """
        H√†m heuristic d·ª± ph√≤ng. S·∫Ω kh√¥ng ph√¢n lo·∫°i TRACK_VQA, ƒë·ªÉ an to√†n.
        """
        query_lower = query.lower().strip()
        
        # C√°c t·ª´ kh√≥a m·∫°nh c·ªßa TRACK_VQA
        track_vqa_keywords = ["ƒë·∫øm", "bao nhi√™u", "li·ªát k√™", "t·∫•t c·∫£ c√°c", "nh·ªØng con", "nh·ªØng c√°i"]
        if any(k in query_lower for k in track_vqa_keywords):
            return "TRACK_VQA" # Heuristic c√≥ th·ªÉ th·ª≠ ph√¢n lo·∫°i TRACK_VQA v·ªõi c√°c t·ª´ kh√≥a m·∫°nh

        # Heuristic cho QNA
        qna_keywords = ['m√†u g√¨', 'ai l√†', 'ai ƒëang', '·ªü ƒë√¢u', 'khi n√†o', 't·∫°i sao', 'c√°i g√¨']
        if '?' in query or any(query_lower.startswith(k) for k in qna_keywords):
            return "QNA"
        
        # Heuristic cho TRAKE
        trake_pattern = r'\(\d+\)|b∆∞·ªõc \d+|\d\.'
        if re.search(trake_pattern, query_lower) or "t√¨m c√°c kho·∫£nh kh·∫Øc" in query_lower:
            return "TRAKE"
        
        return "KIS"

    def perform_vqa(self, image_path: str, question: str) -> Dict[str, any]:
        """
        Th·ª±c hi·ªán VQA s·ª≠ d·ª•ng GPT-4o.
        *** PHI√äN B·∫¢N C√ì X·ª¨ L√ù L·ªñI T·ªêT H∆†N ***
        """
        base64_image = self._encode_image_to_base64(image_path)
        if not base64_image:
            return {"answer": "L·ªói: Kh√¥ng th·ªÉ x·ª≠ l√Ω ·∫£nh", "confidence": 0.0}

        prompt = f"""
        You are a Visual Question Answering assistant. Based on the provided image, answer the user's question.
        
        **Your task is to return ONLY a valid JSON object** with two keys: "answer" and "confidence".
        - "answer": A short, direct answer in Vietnamese.
        - "confidence": Your confidence in the answer, from 0.0 (very unsure) to 1.0 (certain).

        **User's Question:** "{question}"
        """
        
        messages = [
            {
                "role": "user",
                "content": [
                    {"type": "text", "text": prompt},
                    {
                        "type": "image_url",
                        "image_url": {"url": f"data:image/jpeg;base64,{base64_image}"},
                    },
                ],
            }
        ]
        try:
            response_content = self._openai_chat_completion(messages, is_json=True, is_vision=True)
            
            if not response_content:
                print("--- ‚ö†Ô∏è OpenAI VQA kh√¥ng tr·∫£ v·ªÅ n·ªôi dung. ---")
                return {"answer": "Kh√¥ng th·ªÉ ph√¢n t√≠ch h√¨nh ·∫£nh", "confidence": 0.1}

            result = json.loads(response_content)
            return {
                "answer": result.get("answer", "Kh√¥ng c√≥ c√¢u tr·∫£ l·ªùi"),
                "confidence": float(result.get("confidence", 0.5))
            }
        except (json.JSONDecodeError, TypeError) as e:
             # B·∫Øt c·∫£ l·ªói TypeError t·ª´ json.loads(None) v√† JSONDecodeError
            print(f"L·ªói OpenAI perform_vqa (JSON parsing): {e}. Response nh·∫≠n ƒë∆∞·ª£c: '{response_content}'")
            return {"answer": "L·ªói ƒë·ªãnh d·∫°ng ph·∫£n h·ªìi", "confidence": 0.0}
        except Exception as e:
            print(f"L·ªói kh√¥ng x√°c ƒë·ªãnh trong OpenAI perform_vqa: {e}")
            return {"answer": "L·ªói x·ª≠ l√Ω VQA", "confidence": 0.0}

    def decompose_trake_query(self, query: str) -> List[str]:
        """Ph√¢n r√£ truy v·∫•n TRAKE th√†nh c√°c b∆∞·ªõc con."""
        prompt = f"""
        Decompose the Vietnamese query describing a sequence of actions into a JSON array of short, self-contained phrases. Return ONLY the JSON array.

        Example:
        Query: "T√¨m 4 kho·∫£nh kh·∫Øc ch√≠nh khi v·∫≠n ƒë·ªông vi√™n th·ª±c hi·ªán c√∫ nh·∫£y: (1) gi·∫≠m nh·∫£y, (2) bay qua x√†, (3) ti·∫øp ƒë·∫•t, (4) ƒë·ª©ng d·∫≠y."
        JSON: ["v·∫≠n ƒë·ªông vi√™n gi·∫≠m nh·∫£y", "v·∫≠n ƒë·ªông vi√™n bay qua x√†", "v·∫≠n ƒë·ªông vi√™n ti·∫øp ƒë·∫•t", "v·∫≠n ƒë·ªông vi√™n ƒë·ª©ng d·∫≠y"]

        Query: "{query}"
        JSON:
        """
        try:
            response_content = self._openai_chat_completion([{"role": "user", "content": prompt}], is_json=True)
            result = json.loads(response_content)
            if isinstance(result, list):
                return result
            return [query] # Fallback
        except Exception as e:
            print(f"L·ªói OpenAI decompose_trake_query: {e}")
            return [query]